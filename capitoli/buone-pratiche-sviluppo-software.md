# Sviluppo di software scientifico libero

## Fattori di valutazione del software

### Rilevanza per i giuristi

Il capitolo precedente ha dimostrato che da un punto di vista teorico, il software libero è il modello di software che è meglio in grado di soddisfare le esigenze dell'informatica forense.

Questo capitolo si concentra sugli aspetti pratici e tecnici dello sviluppo del software. In primo luogo è importante indicare ai giuristi quali sono gli elementi tecnici utili da menzionare nel contraddittorio per sostenere l'affidabilità del proprio strumento di analisi, e screditare lo strumento dell'altra parte.^[In particolare, è possibile screditare il software proprietario per il solo fatto che non può essere sottoposto allo stesso livello di scrutinio del software libero. Questo non significa che il software libero sia necessariamente libero da difetti, o migliore del software proprietario, ma piuttosto, che è più facile rilevare questi difetti, e che è possibile sapere esattamente come e perché il software funziona.]

### Linguaggio di programmazione

Il primo fattore da valutare, ed il più importante, è il linguaggio di programmazione in cui il software è stato scritto.
Ogni linguaggio di programmazione ha caratteristiche diverse, che possono essere divise in due categorie: caratteristiche che aiutano la creazione di software ad uso scientifico,^[Idealmente, i linguaggi di programmazione dovrebbero tendere verso il "pozzo del successo", ossia, dovrebbero rendere facile seguire le *best practices*, ma soprattutto, dovrebbero rendere difficile non seguirle. V. J. Atwood, *Falling Into The Pit of Success*, 2007, <https://web.archive.org/web/20140402064217/https://blog.codinghorror.com/falling-into-the-pit-of-success/>.] e caratteristiche che rendono più difficile creare programmi che funzionano correttamente.

È preferibile usare:

- Linguaggi *memory-safe* [Nei linguaggi *memory-safe*, la gestione della memoria è completamente automatica, v. @Pasini2019, p. 21] rispetto a linguaggi *memory-unsafe*;^[La gestione manuale della memoria nei linguaggi *memory-unsafe* è la causa della maggioranza dei bug. V. A. Gaynor, *Introduction to Memory Unsafety for VPs of Engineering*, 2019, <https://web.archive.org/web/20190812151808/https://alexgaynor.net/2019/aug/12/introduction-to-memory-unsafety-for-vps-of-engineering/>, e P. Kehrer, *Memory Unsafety in Apple's Operating Systems*, 2019, <https://web.archive.org/web/20190725163137/https://langui.sh/2019/07/23/apple-memory-safety/>.]
- Linguaggi *statically-typed* e *strongly-typed*,^[Ossia, il programmatore deve indicare esplicitamente il tipo di valori che possono essere usati all'interno del programma, e come questi valori devono essere trasformati. V. T. Hurd, *Introduction to Static, Dynamic, Strong and Weak Data Types*, 2021, <https://web.archive.org/web/20210603180908/https://www.sitepoint.com/typing-versus-dynamic-typing/>.] piuttosto che linguaggi *dynamically-typed*;^[I linguaggi *dynamically-typed* sono più facili da sviluppare, e richiedono meno codice, ma il prezzo da pagare è che il controllo sul corretto uso dei tipi avviene solo quando il programma è in fase di esecuzione. Nei linguaggi *statically-typed*, un programma che contiene errori nell'uso dei tipi non potrà nemmeno essere avviato. V. la sez. "Typing" in @Ousterhout1998, 24]
- Linguaggi che usano gli *out-of-band errors*;^[Alcuni linguaggi tendono ad indicare gli errori *in-band*, e restituiscono un singolo risultato, che può essere il risultato dell'operazione, oppure un valore particolare che indica la presenza di un errore. È più difficile verificare la presenza di errori, e le informazioni diagnostiche sono più scarne. V. F. Long, W. Snavely, *ERR52-J. Avoid in-band error indicators*, 2017, <https://web.archive.org/web/20230329034143/https://wiki.sei.cmu.edu/confluence/display/java/ERR52-J.+Avoid+in-band+error+indicators>. È possibile cercare di approssimare un errore *out-of-band* restituendo un singolo valore che contiene al suo interno più elementi, ma è necessario che tutto il codice si adegui a questa nuova convenzione. Ad es., v. Team di Sviluppo GTK, *Error reporting*, 2021, <https://web.archive.org/web/20210921180746/https://docs.gtk.org/glib/error-reporting.html>.]
- Linguaggi che sono maturi^[È preferibile evitare linguaggi nuovi, sperimentali, o che cambiano di frequente, e concentrarsi su linguaggi che esistono da tempo, maturi e stabili. Ad esempio, C/C++, Java e Python sono stati creati decenni fa, sono largamente usati dall'industria, e quindi, è presumibile che continueranno ad essere supportati ed utilizzati nel tempo, senza cambiamenti significativi. Il linguaggio Go è più recente, ma gli sviluppatori hanno promesso che si impegneranno a garantire la retro-compatibilità delle versioni successive del linguaggio con le versioni precedenti. V. R. Cox, *Backward Compatibility, Go 1.21, and Go 2*, 2023, <https://web.archive.org/web/20230814162240/https://go.dev/blog/compat>.] e largamente utilizzati;^[Più un linguaggio è largamente utilizzato, e più è facile trovare risorse tecniche, codice da riutilizzare, programmatori che possono aiutare a migliorare il codice. Ad esempio, i linguaggi C e C++ sono rischiosi da utilizzare nel software scientifico perché *memory-unsafe*, ma allo stesso tempo, hanno larghissima utilizzazione nel mondo della programmazione, e quindi esiste un grande numero di risorse e strumenti che aiutano a sviluppare applicazioni robuste ed affidabili.]
- Linguaggi che sono semplici e *opinionated* rispetto a linguaggi complessi o *unopinionated*.^[Se un linguaggio è flessibile, e offre più modi per risolvere lo stesso problema, programmatori diversi useranno modi diversi, andando a violare il *principle of least surprise* (principio della sorpresa minima), e complicando la comprensione e manutenzione del codice. Ad esempio, basta confrontare il motto del linguaggio Python, *There should be one -- and preferably only one -- obvious way to do it*, con il motto del linguaggio Perl, *There's more than one way to do it*. Per una discussione dei rischi che un linguaggio particolarmente flessibile pone, v. R. Winestock, *The Lisp Curse*, 2011, <https://web.archive.org/web/20110416211304/http://winestockwebdesign.com/Essays/Lisp_Curse.html>.]

Nel caso in cui sia necessario usare dei linguaggi che presentano delle caratteristiche sfavorevoli, è importante che gli sviluppatori cerchino di mitigare i loro effetti, e documentino il loro operato, in modo che i tecnici possano argomentare che il software sia comunque affidabile.^[Ad esempio, i programmi che interagiscono direttamente con i componenti più basilari del sistema operativo (*filesystem*, memoria RAM, interfacce di rete, ecc.) devono essere scritti in linguaggi di basso livello, come C, che però tendono ad essere *memory-unsafe*. Pertanto, è utile usare Valgrind (v.<https://web.archive.org/web/20231113151236/http://valgrind.org/docs/manual/mc-manual.html>) per rilevare i bug relativi alla memoria. Viceversa, i programmi per analizzare i dati tendono ad essere scritti in linguaggi di alto livello, che però tendono ad essere *dynamically-typed*. Pertanto, è utile usare strumenti come MyPy (v. <https://mypy-lang.org/>) per controllare il corretto uso dei tipi. Più in generale, è utile seguire le linee-guida previste per il codice che sarà utilizzato in applicazioni critiche, come i sistemi aerospaziali, v. @Holzmann2006.]


### Documentazione del codice

La documentazione è importante per qualsiasi tipo di software, ma è una necessità imprescindibile per il software ad uso scientifico. Il termine "documentazione" è un termine generico, ed esistono più forme di documentazione, che si differenziano per il loro livello di astrazione^[Ossia, quanto sono vicine alle singole istruzioni di cui il codice è composto.] e finalità.^[In linea generale, la documentazione può servire a spiegare il "perché" il programma è stato progettato in un certo modo, o il "come" funziona e trasforma i dati.]

Così come il codice, anche la documentazione può contenere *bug* (se non è chiara, completa,^[Perché è difficile capire se il programma risponde alle proprie esigenze, o se si sta usando il programma correttamente.] o se è difforme^[Perché è difficile determinare se il programma produce risultati incorretti, oppure la documentazione è incorretta.] rispetto al comportamento del programma)^[V. sez. "Reporting Bugs" in @GNU-C-Library, p. 1121.] ed è soggetta ad una licenza, che deve essere a sua volta libera.^[I criteri per determinare se la documentazione è libera sono la possibilità di ridistribuire copie della documentazione insieme alle copie del codice, e la possibilità di modificare la documentazione, in modo che rifletta le eventuali modifiche apportate al codice. V. @GNU-C-Library, p. 1149]

Si possono distinguere due tipi di documentazione. La prima è la documentazione che interessa principalmente agli sviluppatori:

- I commenti formano parte integrante del codice. Il loro scopo è di chiarire quanto non è immediatamente evidente da una semplice lettura del codice.^[In altre parole, devono realmente essere un "commento" al codice, e non una semplice "traduzione" del linguaggio di programmazione in un linguaggio naturale. Per una lista di buone pratiche relative ai commenti, v. E. Spertus, *Best practices for writing code comments*, 2021, <https://web.archive.org/web/20211223145454/https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/>. In linea generale, tra scrivere codice complesso e spiegarlo con commenti, e scrivere codice semplice che non ha bisogno di commenti, è sempre preferibile la seconda opzione; v. D. Orr, *Write code for humans. Design data for machines.*, 2020, <https://web.archive.org/web/20200402061509/https://douglasorr.github.io/2020-03-data-for-machines/article.html>. Nel caso in cui sia assolutamente necessario scrivere codice complesso, e cercare di semplificarlo è inutile o impossibile, anche questo va indicato nei commenti; ad es.,  v. N. Muller, *XeePhotoshopLoader.m*, 2013, <https://github.com/zepouet/Xee-xCode-4.5/blob/83394493f51991748b9b4706e6d37a8ed874bc05/XeePhotoshopLoader.m>, linee 108 ss.] Nel codice ad uso scientifico, la presenza di commenti è un aiuto fondamentale per comprendere a pieno l'organizzazione ed il funzionamento del software;
- Il *reference manual* (manuale di riferimento) spiega nel dettaglio ogni componente del programma, e permette di studiare il funzionamento del programma senza dover leggere ogni riga del codice sorgente. Esempi di *reference manuals* sono il manuale per la libreria C GNU [Che indica in dettaglio gli standard che vengono implementati, e le eventuali differenze rispetto agli standard, v. @GNU-C-Library], e la documentazione di SQLite.^[Che contiene sia un *reference manual* con diagrammi che spiegano la sintassi del linguaggio SQL, sia numerosi documenti che spiegano come varie funzionalità sono implementate in concreto, e quali considerazioni tecniche hanno portato a quelle scelte; v. <https://www.sqlite.org/docs.html>.] È fondamentale che il reference manual sia aggiornato rispetto al codice a cui fa riferimento.

La seconda è la documentazione che interessa agli utilizzatori finali:

- Le istruzioni su come installare e configurare il software. Questi elementi sono estremamente importanti per garantire il funzionamento corretto e riproducibile del software scientifico;
- Lo *user's manual* (manuale per l'utente) che spiega come utilizzare il software in concreto, e le limitazioni tecniche del programma;^[Laddove il *reference manual* è l'equivalente di un progetto per costruire un prodotto per i produttori, lo *user's manual* è il manuale di istruzioni per i consumatori.]
- I *known bugs*, un elenco di *bug* di cui gli sviluppatori sono a conoscenza, ma non hanno ancora risolto;^[Perché sono bug particolarmente complessi da risolvere, o perché hanno un impatto ridotto. Idealmente, il software non dovrebbe contenere *bug*, ma nella pratica è inevitabile che alcuni *bug* non possano essere risolti immediatamente. Il miglior compromesso è essere messi a conoscenza della presenza di questi *bug*, in modo da tenerli in conto durante la valutazione.]
- Il *changelog* (lista dei cambiamenti) o il file *NEWS* sono file che contengono una descrizione dei cambiamenti fra le varie versioni del programma. Per il software scientifico, è importante indicare tutti i cambiamenti che possono influire in maniera significativa sui risultati;^[Ad esempio, la risoluzione di un bug, o il cambiamento o eliminazione di un metodo di analisi.]
- *Tutorial* e guide, che spiegano in maniera dettagliata come raggiungere un determinato risultato.

Riassumendo, la finalità di questi documenti nel software ad uso scientifico è di garantire che l'utilizzatore finale sia in grado di installare ed utilizzare il programma correttamente, e sia reso consapevole di eventuali *bug* e limitazioni già note agli sviluppatori.

### Uso di codice di terze parti

Per codice di terze parti, si intende il codice scritto da sviluppatori diversi dallo sviluppatore (o sviluppatori) originali (o principali).

Nel caso del software scientifico, si potrebbe argomentare che è preferibile evitare il codice di terze parti, per due ragioni:

- Il codice scritto da sviluppatori di terze parti è generico, e non è sviluppato tenendo a mente i requisiti particolari dell'informatica forense;^[Ad esempio, nel codice generico è meglio dare una riposta approssimativa in tempi rapidi, ma per l'informatica forense è meglio dare una risposta precisa anche se richiede tempi più lunghi.]
- Non si è familiari con il codice scritto da terze parti, e quindi è più difficile stimare se sia affidabile, e modificarlo per allinearlo alle proprie esigenze.^[Viceversa, con il proprio codice si ha cognizione diretta dei *bug*, dei punti deboli e delle limitazioni, e della sua struttura, quindi può essere modificato in tempi minori.]

È possibile confutare entrambe queste nozioni.

I requisiti di funzionamento del software specializzato per l'analisi forense^[Lo strumento di analisi deve essere robusto (gli *input* invalidi devono essere rigettati, e gli errori che si verificano devono essere gestiti in maniera adeguata), deve essere preciso (gli *output* sono corretti). L'analisi deve essere ripetibile (non modificare gli *input* originali), riproducibile (gli stessi *input* producono sempre lo stesso *output*), e dettagliata (deve contenere quante più informazioni diagnostiche utili possibile).] sono condivisi anche dal software "generico". Tutto il software ha interesse a produrre risultati affidabili, l'unica differenza è il bilanciamento fra l'affidabilità e le altre esigenze (efficienza, sviluppo di altre funzionalità, ecc.) [È la tensione fra *doing the right thing* (fare la cosa giusta) e *worse-is-better* (il meglio è il nemico del bene), v. sez. "The Rise of Worse is Better" in @Gabriel2000, 7--10].

Il codice scritto da altri ha il vantaggio di essere stato sottoposto ad un controllo di qualità diffuso, da parte degli utenti^[Quanti più utenti usano il software, ognuno con le proprie configurazioni di hardware e software, tanto più ci si può aspettare che i risultati siano riproducibili, e più *bug* possono essere scoperti e corretti.] e sviluppatori^[Quanti più sviluppatori di terze parti contribuiscono a sviluppare il software, tanto più ci sarà un incentivo a riorganizzare e documentare il codice in maniera che sia di immediata comprensione anche a soggetti che leggono quel codice per la prima volta.]
Specularmente, questi vantaggi diventano svantaggi nel codice nuovo e scritto *ad hoc*. Il fatto che il codice è nuovo significa che è stato messo alla prova solo in un numero limitato di casi, e quindi è intrinsecamente meno affidabile.

Si possono trarre due conclusioni.
La prima è l'opportunità di riutilizzare il codice libero già esistente, dove possibile e ragionevole.^[
Ad esempio, perché non esistono ancora soluzioni mature e largamente affermate. Se invece queste soluzioni esistono, è necessario spiegare perché sono inadeguate, ed è preferibile iniziare da zero. In generale, è sempre preferibile evitare di partire da zero. V. J. Spolsky, *Things You Should Never Do, Part I*, 2000, <https://web.archive.org/web/20170104073437/https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/>.]
La seconda è che in teoria, qualsiasi software libero non-specializzato può essere modificato in modo che risponda alle esigenze dell'informatica forense.^[Viceversa, nel caso del software forense proprietario, potrebbe essere impossibile esaminare il codice sorgente per verificare il corretto funzionamento del programma.]

Quando si usa codice di terze parti all'interno del software scientifico, è utile usare una tecnica chiamata *vendoring*, ossia, includere una copia integrale del codice di terze parti all'interno del proprio software.^[
V. T. MacWright, 2021, *Vendor by default*, <https://web.archive.org/web/20230929010221/https://macwright.com/2021/03/11/vendor-by-default>.]
Questo permette di evitare vari problemi, come il *dependency hell*,^[
Per una definizione del termine e vari esempi, v. O. Barcz, *What is Dependency Hell and How to Avoid it?*, 2021, <https://web.archive.org/web/20230208172253/https://www.boldare.com/blog/software-dependency-hell-what-is-it-and-how-to-avoid-it/>.]
i *supply-chain attacks*,^[
Situazioni in cui un attacco informatico va a compromettere la fonte da cui viene scaricato il software. Ad es., v. D. Goodin, *Backdoor added to PHP source code after breach of internal git server*, 2021, <https://web.archive.org/web/20210329192422/https://arstechnica.com/gadgets/2021/03/hackers-backdoor-php-source-code-after-breaching-internal-git-server/>.]
e garantisce in maniera massima la riproducibilità del software, perché tutti i componenti necessari sono già inclusi nel progetto.

### Controlli di qualità

Esistono vari strumenti che permettono di controllare la qualità del codice, e verificare e garantire che funzioni in maniera corretta e riproducibile anche su sistemi diversi.

I *linter* sono software che controllano se il codice rispetta una serie di regole:^[
V. Fondazione OWASP, *Linting Code*, 2022, <https://web.archive.org/web/20230328005626/https://owasp.org/www-project-devsecops-guideline/latest/01b-Linting-Code>.]

- Le regole stilistiche servono a garantire che il codice sia coerente dal punto di vista estetico;^[Ad esempio, esistono numerose opzioni ed opinioni su dove posizionare le parentesi graffe, se usare tabulazioni o spazi (e quanti spazi) per l'indentazione, dove inserire i ritorni a capo, la lunghezza massima delle righe di codice, ecc. Queste regole possono essere sempre applicate automaticamente.]
- Le regole logiche servono a correggere del codice che presenta problemi diversi dai semplici errori di sintassi, e garantiscono il rispetto delle *best practices* relative a quel linguaggio di programmazione;^[Ad esempio, *shellcheck* contiene centinaia di regole su come scrivere degli *shell script* robusti, v. <https://www.shellcheck.net/wiki/>. In alcuni casi le correzioni possono essere applicate automaticamente, perché esiste una sola soluzione. Altrimenti, è necessario l'intervento del programmatore.]
- Per i linguaggi *dynamically-typed*, i *linter* possono essere usati per controllare il corretto uso dei tipi all'interno del programma.^[Ad esempio, v. MyPy, <https://mypy-lang.org/>.]

I *tests*^[Esistono varie tipologie di test. Gli *unit tests* controllano il funzionamento delle singole "unità" logiche di cui il programma è composto. Gli *integration tests* controllano che più unità funzionano correttamente insieme. Infine, gli *end-to-end tests* controllano che l'intero programma, dall'avvio fino al termine dell'esecuzione, funziona correttamente. In questa sezione, si userà l'espressione *test(s)* si riferisce a tutte e tre le categorie.] servono a controllare il corretto funzionamento del programma.^[Facendo un'analogia con il diritto, mentre i *linter* svolgono un controllo sugli atti (sul codice), di legittimità (puramente formale), e preventivo (prima dell'esecuzione del programma), i *tests* svolgono un controllo sull'attività (i risultati che vengono raggiunti), che per sua natura è sempre successivo. V. @Clarich2022, p. 276--277.]

Un *test* consiste in tre parti: il codice oggetto di test, i dati forniti in *input* al codice, ed il risultato che ci si aspetta in *output*.
Se il risultato prodotto dal codice non corrisponde al risultato aspettato, si dice che il test "fallisce" (*fail*), altrimenti è "superato" (*pass*).

Per il software ad uso scientifico, è estremamente importante eseguire i test^[I test non devono essere eseguiti manualmente, uno ad uno. Esistono programmi chiamati *test runner* che individuano i test, li eseguono, e offrono un resoconto dettagliato dei test non superati, in maniera automatica.] prima di usare un programma, per verificare che funzioni correttamente.^[
È altrettanto importante controllare anche i *tests* stessi. La qualità dei test è molto più importante della loro quantità. Idealmente, i test devono verificare non solo che gli *input* validi siano elaborati correttamente, ma anche, e soprattutto, che gli *input* invalidi vengono correttamente identificati come tali, e rigettati dal programma.]
Nella documentazione relativa all'uso del programma, è importante indicare come eseguire i *tests*, e dare informazioni sommarie riguardo al loro contenuto.^[Ad esempio, indicare che tipi di test sono inclusi (*unit*, *integration*, e *end-to-end*), come sono strutturati, quante casistiche coprono, se ci sono test che potrebbero fallire su/al di fuori di casi particolari, ma questa situazione non incide sul corretto funzionamento del programma in generale, ecc.]

Ancora, è utile adottare la metodologia *TDD* (*test-driven development*, sviluppo guidato dai test), dove i *tests* vengono scritti prima ancora di scrivere il codice.
Questo approccio ha due vantaggi:

- L'insieme dei *tests* diventa una specificazione formale di come il programma si deve comportare, e definiscono i limiti operativi del programma;^[In altre parole, se tutti i *tests* sono superati, e se i dati forniti al programma al momento dell'utilizzazione pratica rientrano nel tipo di dati che sono gestiti correttamente nei *tests*, la conclusione logica è che il risultato prodotto dal programma sarà corretto. Naturalmente, questa conclusione dipende interamente dalla qualità e quantità dei *tests*.]
- Conseguentemente, i *tests* diventano una forma aggiuntiva di documentazione per il codice per gli sviluppatori.^[I *tests* sono una serie di esempi pratici di come usare le funzioni offerte dal codice.]

Inoltre, i test possono essere usati anche dopo che il codice è stato scritto, per evitare le *regressions* (regressioni).^[Una regressione è la situazione che si verifica quando un *bug* corretto in precedenza si ripresenta di nuovo, a seguito di cambiamenti nel codice.] Per rilevarle in maniera automatica, è possibile aggiungere un *test* che controlla la presenza o meno di quel *bug*.

I *fuzzers*^[In inglese, *fuzzy* significa "sfocato" o "confuso", quindi il termine potrebbe essere tradotto in maniera approssimativa come "confonditori".]
sono strumenti che verificano l'affidabilità e robustezza del codice, fornendo *input* casuali al programma, e osservando quali input causano un *crash* del programma.^[Un *crash* è la situazione in cui l'esecuzione del programma termina in maniera inaspettata, e non prevista dal programmatore, perché una situazione di errore non è stato gestita correttamente.]

Idealmente, il programma deve analizzare i dati soltanto nel caso in cui siano invalidi, e terminare l'esecuzione in maniera "aggraziata"^[Spesso in inglese si usano l'aggettivo *graceful* e l'avverbio *gracefully* per indicare che davanti ad un problema, il sistema non si interrompe in maniera "brusca", ma cerca di continuare l'esecuzione, magari offrendo un risultato solo parziale, se l'errore è *recoverable* (può essere corretto), o interromperla offrendo informazioni diagnostiche utili anche ad utenti non-tecnici, se l'errore è *unrecoverable* (è impossible continuare l'esecuzione). In ogni caso, è importante informare l'utente della presenza di qualsiasi problema che non è abbastanza grave da arrestare l'esecuzione, ma che potrebbe influire sulla qualità e quantità dei dati (questo tipo di problemi vengono indicati come *warnings*, avvertimenti).] con un messaggio di errore che indica il problema in maniera specifica in tutti gli altri casi.

Nel caso di un *crash*, il programma termina in maniera "brusca", spesso senza dare all'utilizzatore finale indicazioni utili su quale sia il problema.^[I messaggi prodotti a seguito di un *crash* sono indispensabili per i programmatori, affinché possano identificare la loro causa, ma non sono particolarmente utili per gli utilizzatori del software. Il motivo per cui è importante evitare che il programma termini con l'esecuzione con un *crash*, e sia sempre in grado di dare una risposta è lo stesso motivo per cui esiste il divieto di *non liquet* per i giudici. Un programma che subisce un *crash* (e quindi né analizza i dati, né indica l'errore che ha impedito l'analisi) è come il giudice che conclude il processo affermando che non ci siano leggi applicabili (e non dà ragione a nessuna delle due parti). Più in generale, la presenza di *crash* può far dubitare della qualità del programma, da un punto di vista anche solo puramente psicologico, prima ancora che tecnico.]

Un *fuzzer* è un programma che fornisce *input* casuali per i programmi, e monitora come i programmi si comportano.^[I programmi possono terminare correttamente, terminare con un *crash*, oppure entrare in un *loop* infinito, e non terminare mai l'esecuzione. V. @Miller2022, p. 2030--2031.] Il loro uso permette di rendere il codice più robusto, e capace di gestire il numero maggiore di input possibili in maniera "aggraziata".^[In particolare, l'uso dei *fuzzer* permette di evidenziare gli errori di programmazione più comuni che diminuiscono l'affidabilità del software. V. @Miller2022, p. 2033--2036.]

### Riproducibilità e distribuzione del codice

È estremamente importante garantire che il software ad uso scientifico che è stato creato dagli sviluppatori, e che funziona correttamente sulle loro macchine, funzioni nella stessa maniera anche sulle macchine degli utilizzatori finali.^[Altrimenti, tutti gli sforzi per garantire la qualità del codice fatti fino a questo punto sarebbero inutili, e tutti i vantaggi del software libero diventerebbero lettera morta. Certamente, il codice potrebbe essere studiato, modificato, e ridistribuito, ma verrebbe meno la funzione principale, il poter essere eseguito (con risultati riproducibili).]

Le tecniche di *reproducible builds*^[Nel gergo dell'informatica, *build* è il codice macchina che viene prodotto a seguito della compilazione.] interessano principalmente nell'ambio della sicurezza informatica, perché permettono di rilevare l'inclusione di codice dannoso al momento della compilazione del codice sorgente [In questo tipo di attacco, il codice sorgente è sicuro, ma nel momento in cui viene compilato dall'utente finale per poter essere eseguito, il compilatore aggiunge del codice dannoso. Per l'utente finale, è difficile rilevare la presenza del codice dannoso. Per maggiori dettagli, v. @Thompson1984].

Gli utenti finali, invece di scaricare del codice già compilato da terzi,^[I terzi potrebbero modificare il codice sorgente subito prima della compilazione per aggiungere codice dannoso.] scaricano il codice sorgente, lo compilano di persona, e verificano che il loro risultato è lo stesso risultato che è stato ottenuto dagli sviluppatori originali [@Butler2022, 687--688]. Questo esclude l'inclusione di codice dannoso, ma più in generale, garantisce che il programma si comporterà nello stesso ed identico modo sia per gli sviluppatori originali, sia per gli utilizzatori.^[Questo è il punto che interessa all'informatica forense, la riproducibilità del software di analisi.]

I *container* sono un altro strumento utile per garantire la riproducibilità. Un *container* è un ambiente isolato che viene creato all'interno di un sistema operativo già in esecuzione, e permette di installare ed eseguire applicazioni.^[Hanno una funzione analoga alle *virtual machines* (macchine virtuali). La differenza è che le macchine virtuali simulano l'esecuzione di un intero computer e sistema operativo, mentre i *container* servono soltanto a separare le applicazioni all'interno del container dalle applicazioni già presenti sul sistema. V. I. Buchanan, *Containers vs. virtual machines*, 2024, <https://web.archive.org/web/20240112012831/https://www.atlassian.com/microservices/cloud-computing/containers-vs-vms>.]

I *container* offrono due vantaggi, sono deterministici.^[Ossia, agli stessi input corrispondono gli stessi output. Questo permette di verificare l'integrità del *container*, e di garantire  Ad esempio, i container di Docker vengono definiti con un file di testo chiamato "Dockerfile" (v. <https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>), e sono identificati in maniera univoca da un *hash* (v. sez. "Image digests" in <https://docs.docker.com/engine/reference/run/>).] e contengono solo le applicazioni, non anche i dati.^[Questo significa che un container che contiene il software di analisi può essere distrutto e ricreato facilmente, in modo da partire sempre dallo stesso ambiente iniziale. Ad esempio, di default Docker conserva i dati generati dall'applicazione solo in maniera temporanea, e quando il *container* viene fermato, i dati vengono persi. V. <https://docs.docker.com/storage/>.]

Anche i *container* sono una tecnologia che interessa maggiormente la sicurezza informatica,^[Il fatto che i *container* sono isolati dal resto del sistema serve a prevenire gli attacchi, ed il fatto che sono installabili in maniera automatica elimina eventuali errori umani o problemi di configurazione durante l'installazione.] ma le cui caratteristiche risultano comunque utili per le finalità dell'informatica forense.

## Buone pratiche di sviluppo

### Rilevanza per i giuristi

Questa seconda sezione si concentra sulle buone pratiche relative al processo di sviluppo del software, ed indica gli argomenti che possono essere usati per dimostrare che il modello di sviluppo del software libero non è disorganizzato o produce software di qualità inferiore, solo perché il diritto di modificare e ridistribuire il codice sorgente è garantito a tutti,^[Pertanto, si corre il rischio che entrino in circolazione delle versioni modificate in peggio del software originale.] o perché viene solitamente distribuito gratuitamente.^[Una massima di esperienza è *ex nihilo nihil fit* (nulla viene dal nulla), e pertanto, se qualcosa non costa nulla, non vale nemmeno nulla.]

### Progettazione del software

Nel tempo sono state elaborate varie linee-guida per la progettazione del software. Il principio generale, che può essere desunto da tutte le altre linee-guida [Le regole che vengono menzionate in seguito sono riprese da @Raymond2003, sez. "Basics of the Unix Philosophy".] è di scrivere meno software possibile, e di scrivere il software nella maniera più semplice possibile.

In altre parole, è meglio risolvere un problema complesso usando più programmi (relativamente) semplici e generici,^[Dato che i vari programmi devono comunicare fra di loro, è preferibile che lo facciano usando formati liberi e standardizzati. In ogni caso, è utile anche supportare i formati proprietari, ma i formati liberi dovrebbero essere la scelta principale.] che con un singolo programma complesso e specifico.^[Questa è la logica del *glue code*, il codice che "incolla" insieme più programmi, in modo da creare una sorta di "filiera" per i dati. Per automatizzare operazioni meccaniche, che devono essere ripetute più volte, invece di scrivere manualmente tutti i comandi ogni volta, è molto più semplice scrivere del codice che eseguirà i comandi necessari in sequenza.]

Se non è possibile combinare insieme più programmi, oppure, se il problema non è stato risolto in precedenza, è necessario creare uno nuovo. In questo caso, è utile dividere il programma in due parti: il *front-end* gestisce la presentazione dei dati,^[*Front-end* significa "parte anteriore", l'interfaccia grafica o testuale con cui l'utente finale interagisce direttamente.] mentre il *back-end* gestisce la loro trasformazione.^[*Back-end* significa "parte posteriore", ed è il "motore" del programma, dove i dati vengono modificati prima di essere mostrati all'utente. Questa impostazione rende più facile modificare, estendere, e verificare il corretto funzionamento del singolo programma, dato che le varie parti sono *loosely-coupled* (accoppiate in maniera non rigida).]

Inoltre, dividere in programma in due permette di estrarre il *back-end* come un componente a sé, chiamato *library* (libreria), in modo che possa essere riutilizzato da altri programmi. Un *framework* raccoglie più librerie, combina le loro funzionalità, e offre ai programmatori un'interfaccia unificata per utilizzarle.^[Facendo un'analogia con il diritto, mentre le librerie possono essere considerate analoghe alle leggi, perché sono generiche ed astratte, e generalmente serve la mediazione di altri atti per metterle in pratica, i framework possono essere considerati analoghi ai testi unici, perché raccolgono e armonizzano più leggi speciali.]

### Scelta di una licenza libera

La Free Software Foundation offre alcune indicazioni per scegliere una licenza [@FSFHowToChooseALicense]:

- La Licenza Apache 2.0^[V. <https://web.archive.org/web/20040202124049/http://www.apache.org:80/licenses/LICENSE-2.0>.] è non-*copyleft*, e può essere utilizzata per programmi particolarmente semplici;^[Ad esempio, il *glue code* che viene utilizzato per l'estrazione o la presentazione di dati. In questo caso, le eventuali modifiche fatte dalla controparte dovrebbero essere comunque comunicate all'interno del contraddittorio.]
- La GNU GPL [Dato che esistono più versioni della GPL, è importante aggiungere "e versioni successive", in modo che il software sia sempre compatibile anche con le eventuali versioni successive della GPL, v. @Stallman-Identify-licenses-clearly] viene consigliata come la scelta da preferire in generale;
- La GPL è indicata anche per le librerie software che risolvono problemi nuovi, per cui non esistono altre librerie;^[Questo impone ai programmatori una scelta: scrivere il codice da zero, oppure usare la libreria con licenza GPL, e adottare la licenza GPL anche per il loro programma.]
- Altrimenti, se esistono già altre librerie che svolgono funzioni simili, è preferibile usare la licenza LGPL,^[V. <https://web.archive.org/web/20070701212426/http://www.gnu.org/licenses/lgpl-3.0.html>.] che invece non è copyleft.^[L'idea è di incentivare comunque l'uso del software libero (le altre librerie potrebbero essere non-libere), senza costringere i programmatori ad usare la licenza GPL per il loro programma.]

### Sistemi di controllo di versione

I sistemi di controllo di versione (*version control system*, *VCS*) sono lo strumento che più di ogni altro permette lo sviluppo ordinato del software, anche in presenza di più collaboratori.^[In questa sezione si farà riferimento alla terminologia ed ai concetti usati da Git, un VCS sviluppato originariamente per gestire lo sviluppo del kernel Linux, ma attualmente usato dalla stragrande maggioranza degli sviluppatori, e recentemente, persino dalla Microsoft. Oltre a Git, esistono anche altri sistemi. V. R. Donovan, *Beyond Git: The other version control systems developers use*, 2023, <https://web.archive.org/web/20230109140009/https://stackoverflow.blog/2023/01/09/beyond-git-the-other-version-control-systems-developers-use/>. Per un'introduzione pratica all'uso di *Git*, si rimanda a @Chacon2023]. La funzione di un VCS è di tenere traccia dei cambiamenti che sono stati apportati ad uno o più file. Un gruppo di cambiamenti si chiama *commit*,^[Il sostantivo *commit* fa parte del gergo specializzato dell'informatica. In inglese, uno dei possibili significati del verbo *to commit* è "affidare". Pertanto, *commit* può essere tradotto come "affidamento", nel senso che i dati vengono "affidati" al *repository* affinché li conservi.] ed i *commits* sono conservati all'interno di un *repository* (deposito). I VCS permettono di:

- Ottenere una copia del repository;^[Il comando *git clone* permette di creare una copia di un intero repository. In altre parole, non si ottiene una semplice copia del codice, ma anche della cronologia di sviluppo di quel codice. Git chiama il repository originale *origin*.]
- Creare nuovi *commits*;^[Il comando *git commit* permette di creare nuovi *commit*. Ogni *commit* è identificato in maniera univoca da un *hash*, che viene calcolato combinando insieme varie informazioni, come i cambiamenti che sono stati apportati ai file rispetto all'ultimo *commit*, l'autore (opzionalmente i commit possono anche essere firmati digitalmente con firma crittografica), la data ed ora di creazione, una spiegazione relativa ai contenuti, ecc. e l'hash dell'ultimo commit. Questo ultimo elemento rende la catena dei commit a prova di manomissione. Se si modifica un commit all'interno del repository, si deve ricalcolare il suo hash, e conseguentemente, l'hash di tutti i commit successivi. Questo repository manipolato sarà valido, perché gli hash sono corretti, ma conterrà una serie di commit che non esistono con le copie del repository non manipolate, e pertanto, non sarà sincronizzabile con esse.]
- Sincronizzare i propri *commits* con quelli di altri;^[Il comando *git push* invia i commit presenti nella propria copia del repository al repository originale, mentre *git pull* permette di scaricare i nuovi commit nel repository originale nel proprio. È importante notare che *git push* può essere usato solamente dagli utenti che hanno sono stati autorizzati ad usarlo, e non da chiunque.]
- Lavorare in parallelo su più funzionalità;^[Il comando *git branch* permette di creare dei "rami". Un "ramo" consiste in una serie di commit, ed un nome per identificarli. Normalmente, un *repository* ha un ramo principale (*master*, *main* o *trunk*), che contiene il codice considerato stabile ed affidabile, e uno o più rami chiamati *topic* o *feature branches*, che contengono i *commit* non ancora considerati stabili. Questo permette agli sviluppatori di sperimentare liberamente, perché è sempre possibile tornare al ramo principale, ed ignorare le modifiche.]
- Verificare l'integrità del *repository*;^[Prima di usare il codice, è necessario confermare che il *repository* sia integro. L'uso di *hash* permette di rilevare qualsiasi modifica (accidentale o intenzionale) al *repository* con il comando *git fsck* (abbreviazione di *file-system check*).]
- Estrarre versioni specifiche del codice dal *repository*;^[Il comando *git checkout* può essere usato per estrarre un commit specifico. È il comando che permette di garantire in piena misura la riproducibilità del software di analisi, anche a distanza di tempo. A questo fine, è necessario indicare l'hash del *commit* è stato usato per svolgere l'analisi nella relazione.]
- Esaminare la catena dei commit per studiare l'evoluzione del programma,[^CasoGlobaleaks] chi ha introdotto determinati cambiamenti,^[Il comando *git blame* (letteralmente, "dare la colpa"), permette di associare ad ogni riga di codice l'ultimo commit che l'ha aggiunta o modificata.] o per individuare l'esatto commit che ha introdotto un certo bug.^[Usando il comando *git bisect*.]

[^CasoGlobaleaks]: Ad esempio, è possible esaminare un repository per studiare i casi di violazione delle licenze. *GlobaLeaks* è distribuito con la licenza *copyleft* AGPL. L'ANAC modifica GlobaLeaks, ed il 14 gennaio 2019 lo distribuisce sotto il nome di *OpenWhistleblowing* con una licenza diversa, la Licenza Pubblica dell'Unione Europea. Dopo qualche mese, la licenza viene correttamente ripristinata alla AGPL. V. Centro Hermes, *The Italian National Anti-Corruption Authority (ANAC) and the Hermes Center settle a dispute over the aplication of the AGPL license to GlobaLeaks-based OpenWhistleblowing software*, 2020, <https://web.archive.org/web/20201019132745/https://www.globaleaks.org/anac-and-the-hermes-center-settle-a-dispute-over-the-application-of-the-agpl-license-to-globaleaks-based-openwhistleblowing-software/>. È possibile visualizzare i *commits* che hanno modificato il file "LICENSE" (v. <https://github.com/anticorruzione/openwhistleblowing/commits/master/LICENSE>), e notare che la violazione della licenza AGPL è iniziata il 14 gennaio 2019, ed è terminata il 24 ottobre 2019.

### Contribuzioni di terze parti

Le contribuzioni di terze parti sono una conseguenza naturale dello sviluppo del software libero.
Se tutti hanno il diritto di ottenere una copia del codice e modificarlo, chi corregge dei *bug*, o aggiunge delle funzionalità nella propria copia può desiderare di condividere questi miglioramenti con gli sviluppatori originali.

Queste modifiche sono chiamate *patch*.^[Letteralmente, "pezze", perché saranno metaforicamente "cucite" all'interno del codice.] Il solo fatto che un soggetto terzo invia una *patch* agli sviluppatori originali non significa che sarà automaticamente inclusa,^[Questo è forse il malinteso più comune riguardo il software libero: se il codice è libero, e quindi chiunque è libero di inviare *patch*, allora qualsiasi contribuzione sarà accettata.]
perché il software può essere libero e *open-source*, ma *closed-contribution*.^[Ad esempio, *litestream* era un progetto che non accettava contribuzioni da parte di terzi. V. B. Johnson, *litestream*, 2021, <https://github.com/benbjohnson/litestream/tree/4d41652c12c182d7f0721cc8eda0e3c78d98bae0>. Attualmente, il progetto accetta contribuzioni di terze parti.]

È utile che gli sviluppatori del software libero ad uso scientifico definiscano un processo per accettare le contribuzioni:

- Indicare il tipo di *patch* che gli sviluppatori desiderano;^[È utile che gli sviluppatori indichino sia i *goals* (obiettivi) del progetto, che i *non-goals* (obiettivi al di fuori dell'ambito del progetto). I *non-goals* permettono di concentrare gli sforzi di sviluppo sugli elementi realmente essenziali, e di evitare il *feature creep* (eccesso di funzionalità). È preferibile avere pochi strumenti di analisi altamente affidabili, che un grande numero di metodi il cui funzionamento non è stato verificato in maniera esaustiva.]
- Definire i requisiti per la *patch*,^[Questi requisiti interessano ai contributori esterni. Ad esempio, il kernel Linux ha delle linee-guida dettagliate sul contenuto e formato per le patch. V. Comunità di sviluppo del kernel, *Submitting patches: the essential guide to getting your code into the kernel*, n.d., <https://web.archive.org/web/20180828081227/https://www.kernel.org/doc/html/v4.17/process/submitting-patches.html>] e le modalità di *code review* (revisione del codice), per verificare la qualità del codice;^[Questi elementi riguardano l'organizzazione interna del progetto, ma per motivi di trasparenza, è preferibile renderli pubblici. In particolare, si devono indicare la persona o persone che andranno a controllare che la *patch* sia pertinente al progetto, che segue lo stile del codice seguito dal progetto, che non presenti bug manifestamente evidenti, e che non contenga contribuzioni in mala fede. Ad esempio, c'è stato un esperimento in cui dei ricercatori hanno inviato delle *patch* contenenti bug al kernel Linux, allo scopo di verificare se gli addetti alla *code review* le avrebbero rigettate o meno. V. @Wu2021 e S. J. Vaughan-Nichols, *Greg Kroah-Hartman bans University of Minnesota from Linux development for deliberately buggy patches*, 2021, <https://web.archive.org/web/20210421203003/https://www.zdnet.com/article/greg-kroah-hartman-bans-university-of-minnesota-from-linux-development-for-deliberately-buggy-patches/>.]
- Definire i soggetti che hanno il *write access* (accesso in scrittura) sul repository disponibile al pubblico, e che contiene il codice sorgente;^[Questo è il punto più importante. Anche se chiunque può scaricare una copia del repository, modificarla, e inviare una *patch*, soltanto alcune persone possono effettivamente includere la patch all'interno del *repository* originale. Volendo, è possibile creare un *fork* (bivio), ossia, una copia del *repository* originale che viene gestita da sviluppatori diversi, e contiene le modifiche di questi ultimi. Di solito i *fork* sono creati se il progetto originale è stato abbandonato, oppure se gli sviluppatori originali si rifiutano di includere delle *patch*.]
- Infine, è utile richiedere l'accettazione di un *CLA* (*contributor license agreement*, accordo sulla licenza per chi contribuisce) come condizione per includere il codice di terze parti.^[L'obiettivo è di evitare dubbi riguardo a chi appartengano i diritti intellettuali relativi al codice. Ad esempio, la FSF richiede che i terzi, che contribuiscono codice a programmi di cui la FSF detiene il diritto d'autore, conferiscano alla FSF i diritti d'autore relativi alla loro contribuzione. V. E. Moglen, *Why the FSF Gets Copyright Assignments from Contributors*, 2022, <https://web.archive.org/web/20220102214048/https://www.gnu.org/licenses/why-assign.html>.]

### Sviluppo trasparente del software

In generale, lo sviluppo del software libero deve essere condotto nella maniera più trasparente possibile.^[Per "trasparenza" si fa riferimento allo stesso valore tipico del diritto amministrativo, che serve a garantire un controllo diffuso sull'attività ed organizzazione nel diritto amministrativo. V. @Clarich2022, pp. 153--154, 306--307.] Chi sviluppa software libero è tenuto (idealmente) a condividere non solo il codice, ma anche:

- Informazioni come la documentazione progettuale, le discussioni fra gli sviluppatori che sono rilevanti per il progetto, gli obiettivi di medio e lungo termine, e così via;^[Sono tutte informazioni che hanno rilevanza solo "interna", ma che comunque non sono "riservate", e che quindi è opportuno rendere disponibili al pubblico, anche se l'utilità di condividerle non è immediatamente apparente. Anche il solo fattore psicologico di sapere che il progetto si comporta come se "non abbia nulla da nascondere" ispira fiducia nell'opera degli sviluppatori.]
- Le qualificazioni dei soggetti che hanno contribuito al progetto;^[Nel diritto amministrativo, è fondamentale dimostrare che le persone abbiano le competenze necessarie per ricoprire una determinata carica. Nello sviluppo del software libero, è utile dimostrare che il software non viene necessariamente sviluppato solo da dilettanti e volontari, ma anche da persone con esperienza professionale, o impiegati di compagnie che hanno pubblicato del software libero.]
- Le discussioni fra utenti, o fra sviluppatori ed utenti, su come usare il software;^[Si potrebbe affermare che queste discussioni sono una forma ulteriore di documentazione per il software, specie se rispondono a domande come, "Come posso fare per &hellip;?" (spiegano come raggiungere un certo risultato), oppure "È possibile usare questo software per &hellip;?" (definiscono la destinazione d'uso del software).]
- Le discussioni riguardo la segnalazione di *bug*;^[Anche queste discussioni sono una forma di documentazione, perché individuano le situazioni in cui un bug si verifica, le possibili soluzioni alternative da usare fino alla sua soluzione, indicano come il bug è stato risolto, possono essere utili per la soluzione di bug futuri, ecc.]
- Le discussioni a seguito dell'invio di *patch*;^[Così come le discussioni per i *bug*, formano una sorta di "documentazione storica" per il codice, e servono a spiegare le motivazioni per cui il codice è stato modificato in un certo modo.]
- Impostare un sistema di *CI* (*continuous integration*, integrazione continua).^[Un sistema CI permette di eseguire i *tests* e compilare il software in maniera automatica, appena un *commit* viene pubblicato, o prima di integrare una *patch* all'interno del codice. Possono essere impostati per verificare che il software funzioni correttamente su più piattaforme e configurazioni, e forniscono informazioni dettagliate a seguito di problemi. L'uso di un sistema di CI permette di individuare i bug il prima possibile, e garantisce che il software continua a funzionare correttamente nel corso dello sviluppo. V. RedHat.com, *What is CI/CD?*, <https://web.archive.org/web/20231213065115/https://www.redhat.com/en/topics/devops/what-is-ci-cd>.]

Per gestire quanto sopra indicato, si possono seguire due strade.

La prima consiste nell'usare servizi integrati, ma proprietari, come GitHub^[V. <https://github.com/>.] o GitLab.^[V. <https://about.gitlab.com/>.] Il vantaggio è la facilità d'uso,^[I servizi offrono interfacce grafiche per molte operazioni, sono ampiamente documentati, i vari componenti (gestione del codice, delle discussioni e bug, CI) sono già installati e configurati.] lo svantaggio è la dipendenza da una piattaforma proprietaria.^[Non si ha il pieno controllo della piattaforma (ad esempio, GitHub aveva temporaneamente disattivato il repository di *youtube-dl* a seguito di una diffida da parte della RIAA: v. <https://github.com/github/dmca/blob/1de32ff91eba5b48334b04d72bc69aa6cbb50359/2020/10/2020-10-23-RIAA.md>; il repository fu riattivato dopo alcune settimane, senza modifiche significative al codice: v. A. Maxwell, *GitHub Reinstated YouTube-DL But Restoring Forks is Apparently a Problem*, 2021, <https://web.archive.org/web/20210417214135/https://torrentfreak.com/github-reinstated-youtube-dl-but-restoring-forks-is-apparently-a-problem-210417/>), si può cadere in situazioni di *vendor lock-in* (si rimane "intrappolati" su un servizio, perché non offre il modo di esportare i dati), il servizio può usare il codice o dati per finalità commerciali e senza il permesso degli sviluppatori (ad esempio, si pone il problema se il codice rilasciato con licenza GPL possa essere usato per creare intelligenze artificiali che generano codice: v. FOSSA Editorial Team, *Analyzing the Legal Implications of GitHub Copilot*, 2021, <https://web.archive.org/web/20221105223552/https://fossa.com/blog/analyzing-legal-implications-github-copilot/>).]

La seconda è di usare alternative libere ai servizi proprietari, come Gitea,^[V. <https://github.com/go-gitea/gitea>, che ha un'interfaccia molto simile a quella delle piattaforme proprietarie.] e fare *self-hosting*.^[Un servizio *self-hosted* è un servizio che viene amministrato *in-house*, dalla stessa persona che lo usa, e non da terzi.] Il vantaggio è che si ottiene il pieno controllo della piattaforma,^[Gitea è software libero, quindi è possibile leggere e modificare il codice sorgente, e non ci si deve preoccupare il gestore del servizio possa sospendere l'accesso al repository.] ma al tempo stesso, si diventa responsabili della amministrazione del server su cui i dati risiedono.^[Con i servizi proprietari, lo sviluppatore non si deve minimamente preoccupare della gestione del server (installazione e configurazione del software, configurazione del server, installazione degli aggiornamenti, garanzia dell'*uptime* e della sicurezza informatica, ecc.) su cui risiedono i dati. Viceversa, con il *self-hosting*, il rischio di attacchi informatici contro il codice aumenta notevolmente, dato che gli sviluppatori individuali non hanno le stesse risorse e competenze di una grande compagnia.]
