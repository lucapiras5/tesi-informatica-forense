#+TITLE: Scaletta
#+AUTHOR: Luca Piras

* Introduzione

** Oggetto della tesi

- Come il free open-source software (FOSS) può beneficiare le discipline della information security (InfoSec) e digital forensics (DF).

** Struttura

*FOSS.*

- Definizione dei due modelli per il software: proprietario, o free, open-source software (FOSS).
- Questioni legali relative ai due modelli.



- Problema della compilazione del codice sorgente (collegamento con la reverse-engineering).
- Problema della riproducibilità del codice macchina a partire dal codice sorgente (reproducibile builds).

*Problemi legati alla verifica del funzionamento dei programmi.*

- Problema della verifica del funzionamento del software (test-driven development).

- Vantaggi e svantaggi tecnici dei due modelli.
- Interazioni fra software proprietario, FOSS, sicurezza informatica e DF in alcuni campi specifici: reverse engineering, test-driven development, reproducibile builds.

*GNU/Linux.*

- Problema fondamentale dell'informatica: hardware e software tendono ad essere "scatole nere" di cui non si conosce l'esatto funzionamento, e pertanto sono intrinsecamente inaffidabili.
- GNU/Linux come sistema operativo completamente FOSS, di cui si conosce l'esatto funzionamento.
- Linux come "fondamenta affidabili" su cui costruire sistemi per la InfoSec e DF, che a loro volta fanno uso di programmi FOSS.

*Sicurezza informatica.*

- Obiettivi della sicurezza informatica (information security, InfoSec), rapporto con la DF.
- Integrità e confidenzialità delle informazioni (crittografia).
- Strumenti per valutare la sicurezza di software, anche se proprietario.
- Strumenti per certificare la sicurezza di software, anche se proprietario.
- Uso di GNU/Linux e altri componenti FOSS per creare server sicuri.

*DF.*

- Obiettivi dell'informatica forense (digital forensics, DF), rapporto con la sicurezza informatica.
- Riferimenti normativi e tecnici per il trattamento (acquisizione) e valutazione (all'interno di un processo) della prova informatica.
- Vantaggi specifici che offre il FOSS per la DF rispetto al software proprietario, da un punto di vista tecnico (conoscibilità dei metodi di analisi, riproducibilità dei risultati) e legale (rispetto del giusto processo)
- Esempi di attività tipiche e tispettivi software FOSS utilizzabili per la DF.

* Software proprietario

*Rilevanza.*  Per comprendere l'utilità del software libero, è necessario prima definire cosa si intende per software non libero (proprietario).

*Protezione legale per il software.*  Il software può essere protetto dal diritto d'autore, da brevetti, come segreto industriale, da contratti che vincolano l'utilizzatore finale (EULA).

*DMCA, Information Society Directive.*  Il diritto d'autore regola la gestione dei diritti digitale mediante software (digital rights management, DRM), si prevede il divieto di interferire con questo software.

* Software libero e licenze open-source

*Libertà fondamentali.*  Il software libero invece di vincoli prevede una serie di libertà per gli utilizzatori, che vengono garantite con gli strumenti del diritto d'autore.

*Licenze libere.*  Garantiscono la possibilità di studiare il funzionamento del programma, modificarlo, ridistribuirlo, ed eseguirlo per qualsiasi motivo.

*Licenze copyleft.*  Eventuali modifiche al programma devono essere ridistribuite con la stessa licenza copyleft, il codice sorgente (v. sez. succ.) deve essere sempre disponibile, la licenza obbliga il rispetto delle libertà.

# Tivoization (GPLv3), Affero GPL, LGPL

*Licenze permissive.*  L'uso del codice richiede di citare gli autori, ma eventuali modifiche non devono essere rilasciate al pubblico (ossia, possono rimanere proprietarie).

# Varie versioni della licenza MIT

* Codice sorgente, compilazione

*Codice sorgente, codice macchina.*  I computer possono eseguire solo codice macchina, ma per un programmatore umano è difficile ragionare e scrivere in codice macchina.  Con l'aumentare della complessità dei processori, diventò possibile, se non necessario, sviluppare i linguaggi di programmazione, che introducono una serie di astrazioni rispetto al codice macchina (variabili, funzioni, strutture di dati, ecc...)

# Maggiore sicurezza, DRY, maggiore corrispondenza fra algoritmo e programma, etc.

I linguaggi di programmazione devono essere convertiti in codice macchina, e la conversione può avvenire in tre modi diversi.  Si distingue fra linguaggi di programmazione compilati, interpretati, e convertiti in bytecode.

# Linguaggi interpretati, bytecode.

*Compilazione è irreversibile.*  La compilazione è la trasformazione definitiva da linguaggio di programmazione a codice macchina, ed è di fatto irreversibile.  È difficile capire le operazioni che un codice macchina sta compiendo (non sono presenti commenti, i nomi delle variabili e delle funzioni sono convertiti in indirizzi di memoria e serve studiare il codice istruzione per istruzione), ed è quasi impossibile ritornare al codice sorgente originale.

# Debug symbols, obfuscation

*Compilazione è necessaria.*  La compilazione è "utile" per chi crea software proprietario e non vuole rendere il codice sorgente originale disponibile, ma è un "male necessario" anche per il software libero, che altrimenti non potrebbe essere eseguito.

*Programmi interpretati.*  Nel caso dei programmi interpretati, solo un programma detto "interprete" è compilato, ed la sua funzione è di leggere il codice sorgente, e convertirlo in codice macchina sul momento, senza doverlo compilare.  In questo caso, non si perde nessuna informazione, ma il costo è che l'esecuzione del programma è molto più lenta rispetto ad un linguaggio compilato.

# Compilazione bytecode, JIT, minifier per offuscare.

*Conversione in bytecode.*  I programmi convertiti in bytecode vengono prima "compilati" in un codice macchina particolare, creato ad-hoc per quel linguaggio, detto bytecode.  Successivamente, il bytecode viene interpretato da un secondo programma.  L'esecuzione del codice è più veloce rispetto ai programmi interpretati, e rispetto ai programmi compilati, è più facile recuperare informazioni come il nome delle variabili, funzioni, ecc.

* Unit testing, Test-driven development

** Rilevanza

In generale, è necessario garantire che il programma si comporti correttamente, mediante l'esecuzione automatica di test, che rappresentano una "lista di controllo" per come il programma si deve comportare (quali output deve produrre), dati certi input.

** Definizione

Per /unit testing/ si intende scrivere un test per verificare il funzionamento di una parte (/unit/) del programma.  Generalmente, i test sono scritti per verificare il funzionamento di parti del codice sorgente.

È possibile verificare anche il funzionamento di codice macchina proprietario, già compilato.  Tuttavia, in questo caso i test sono eseguiti in maniera meno efficiente, e se falliscono, non è possibile ispezionare il codice sorgente per capire cosa abbia causato l'errore.

In generale, si prepara una specificazione tecnica (cosa ci si aspetta dal programma), una lista di /unit tests/ (una serie di "obbligazioni di risultato", che definiscono un "contratto" che il software deve rispettare), e se il software supera tutti i test, si può dire che è conforme alla specifica tecnica.

I test sono utili anche per prevenire le regressioni del software: dopo che un bug viene corretto, si scrive un test che controlla che quel bug non si ripeta, anche se il software viene modificato in seguito.

La /test-driven development/ è una filosofia di sviluppo in cui si scrivono prima i test, in modo da definire in anticipo come si vuole che il programma si comporti, per un dato input;  e successivamente, si scrive il codice che soddisfa i test, in modo che:

- L'applicazione contiene solo il codice strettamente necessario per il suo funzionamento, secondo quanto specificato dai test;
- Tutto il codice contenuto nell'applicazione è "affidabile", nel senso che esistono test che dimostrano il suo corretto comportamento per una serie di input.

** Sicurezza informatica

Oltre all'uso "normale" dei test, nell'ambito della sicurezza informatica si possono sviluppare serie di test per verificare in maniera meccanica se un'applicazione o un sistema è vulnerabile ad una serie di attacchi informatici tipici (/cross-site scripting/, /cross-site request forgery/, /SQL injection/, /directory traversal attack/, etc.).

Dato che questi test non riguardano il codice sorgente, ma interagiscono con l'applicazione così come lo farebbe un utente normale, è possibile utilizzarli anche con software proprietario.

Gli schemi di certificazione per la sicurezza informatica di un sistema proprietario possono includere una serie di test.  È importante che il codice sorgente del programma che esegue questo tipo di test sia reso pubblico:

- Si garantisce una peer-review diffusa, ed il pubblico può contribuire aggiungendo o migliorando i test esistenti.
- Se anche il codice sorgente del programma usato per verificare un sistema è proprietario, non ci sono elementi pubblicamente conoscibili, e si è obbligati a fidarsi di due "scatole nere".  Se almeno l'elemento che compie la verifica è conoscibile, si può porre maggiore fiducia nell'altro.

** Informatica forense

Lo stesso ragionamento fatto per il software proprietario si applica anche qui.  Inoltre, nel caso di software FOSS, distribuire programmi e test insieme permette di sapere quali funzioni sono disponibili, in quali condizioni vengono messe alla prova, quali risultati ci si aspetta di ottenere.

I test sono fondamentali per l'informatica forense, dato che dimostrano che anche se il programma viene modificato o ristrutturato, continua a produrre gli stessi risultati a parità di input.  Se un test fallisce, è possibile determinare in quale parte del codice sorgente è contenuto l'errore.  Avere piena fiducia nel corretto funzionamento del codice sorgente significa avere piena fiducia nei risultati che vengono prodotti dal codice macchina, una volta che viene compilato.

* Reverse engineering

** Rilevanza della RE

Quando non si è in possesso del codice sorgente per un determinato programma, per studiare il suo funzionamento, ed eventualmente creare una re-implementazione FOSS di quel sistema o software, è necessario usare tecniche di reverse engineering.

** Definizione di RE

La reverse engineering (RE) viene usata per cercare di ricostruire il funzionamento di un programma compilato o convertito in bytecode, specie nel caso di programmi compilati.  La RE studia come il software si comporta (così come la scienza studia i fenomeni naturali) per documentare in via "induttiva" il suo funzionamento.

** Sicurezza informatica

Per quanto riguarda la sicurezza informatica, la RE può essere usata per:

- Rimuovere sistemi di protezione (ad es., aggirare i sistemi di sicurezza di un dispositivo per estrarre dati, installare un captatore informatico...)
- Studiare malware (ad es., capire come un malware infetta un computer, che effetti provoca, come rimuoverlo...)

# Caso di ransomware disabilitato.

** Informatica forense

- Documentare formati proprietari (ad es., il filesystem NTFS di Windows, in modo che possa essere letto anche su sistemi Linux).
- Riprodurre un software proprietario, in maniera da creare un programma che funziona esattamente allo stesso modo, ma il cui codice sorgente è libero (ad es., un programma che permette di leggere e scrivere su dischi formattati con NTFS).
- Documentare il funzionamento di un sistema operativo o programma, per capire dove trovare le tracce sono prodotte dal loro utilizzo, quali informazioni si possono ricavare da queste tracce, e capire se queste tracce sono state alterate (accidentalmente o volontariamente).

** Limiti legali alla RE

Anche quando si agisce per fini pubblici (ad es., al servizio di un procedimento o processo penale), la RE entra in tensione con il diritto d'autore.

- Aggirare sistemi di protezione per i dati può essere espressamente vietato dalla legge.  Ad es., aggirare gli schemi DRM è una violazione del DMCA e della Information Society Directive.
- Il software o documentazione prodotti a seguito della RE potrebbe essere considerata una violazione del diritto d'autore, perché potrebbe essere necessario copiare dei dati dal software proprietario (ad es., chiavi crittografiche), o perché riproduce la stessa struttura del programma (interfacce software/API come in Google v. Oracle, /substantial similarity/).
  # Cfr. le chiavi SEGA, le chiavi dei DVD e Blu-Ray.

Art. 6 della European Software Directive: la RE è ammessa solo per fini di interoperabilità, non per creare programmi che hanno sostanzialmente la stessa funzione.
# https://lwn.net/Articles/134642/

La legge ed i giudici devono riconoscere delle eccezioni e limitazioni al diritto d'autore come il "fair use" americano, quando la RE è a fini educativi o informativi.

* Reproducibile builds

** Rilevanza

Se del codice sorgente o macchina proviene direttamente dagli sviluppatori originali, è affidabile.

Se il codice passa per soggetti terzi (ad es., viene ridistribuito come /mirror/, diffuso su un /content delivery network/, trasformato in un pacchetto installabile), che non sono gli sviluppatori originali, diventa "inaffidabile", perché questi soggetti potrebbero introdurre cambiamenti, all'insaputa degli sviluppatori originali.

Per ristabilire la fiducia, diventa necessario dimostrare la paternità (ossia, che un determinato sviluppatore ha scritto o approvato delle modifiche) ed integrità (ossia, che il codice non è stato modificato da errori di trasmissione, o manomesso da terzi) dei dati.

Nel caso del codice macchina proprietario, si può solo applicare una firma digitale al codice macchina che viene rilasciato, e verificare la firma con l'autore del software.  

Nel caso di codice sorgente, oltre ad applicare una firma digitale al codice sorgente, si può anche allegare un /build script/ (programma per compilare il software) con delle impostazioni che garantiscono che il codice macchina prodotto rimane lo stesso, a parità di codice sorgente, anche in caso di più compilazioni.

Nel secondo caso, gli utilizzatori finali possono verificare che il codice macchina prodotto dal compilatore corrisponde esattamente al codice macchina che gli sviluppatori originali hanno ottenuto, con maggiori garanzie riguardo il fatto che il programma si comporta esattamente come gli sviluppatori volevano.

** Sicurezza informatica

Si presuppone che gli sviluppatori originali abbiano interesse a produrre codice sicuro, e che se il codice viene ridistribuito, terzi possono avere interesse ad aggiungere modifiche che lo rendono vulnerabile.

Verificare che il codice macchina che è stato scaricato, o che è stato compilato di persona, corrisponde al codice macchina che gli sviluppatori hanno ottenuto indica che quel programma è "affidabile", nel senso che non ci sono state manomissioni di terzi.

** Informatica forense

Per l'informatica forense il problema principale non è che il codice sia "sicuro" rispetto ad attacchi di terzi, ma che si comporti in maniera "prevedibile", che nulla sia rimesso al caso.

Anche in questo caso, le reproducible builds sono utili, perché se il programma viene ricompilato su più sistemi, si garantisce che si ottiene sempre lo stesso codice macchina, e quindi una garanzia molto maggiore che lo stesso codice sorgente si comporti sempre nello stesso modo anche dopo essere stato compilato.

* Confronto tra software proprietario e FOSS

** Introduzione

Chiarita la distinzione fra software proprietario e open-source, ed esplorate alcune tematiche relative all'importanza del codice sorgente, è necessario approfondire 

** Vantaggi del software proprietario del software libero
*** Mancanza di supporto dalle grandi aziende
- Le grandi aziende potrebbero non volere (per non rivelare i loro segreti industriali) o non potere (per ragioni legali di proprietà intellettuale) offrire software open-source.
- Ad es., mentre Intel e AMD offrono driver open source per le loro schede video, in modo che possano essere utilizzate su Linux, Nvidia ha tradizionalmente fornito solo driver closed-source, ed ostacolato l'uso dei loro prodotti con Linux.
*** Finanziamenti
- Spesso, ma non sempre, il software open-source è sviluppato da volontari.  Questo non vuol dire che la qualità del codice sia minore, gli sviluppatori sono pur sempre professionisti, o comunque hanno esperienza tecnica, ma significa che gli sviluppatori non possono dedicare la loro piena attenzione al progetto.
- Il problema può essere risolto vendendo assistenza tecnica per il prodotto open-source (ad es., servizi di consulenze, offrendo di sviluppare certe funzionalità in cambio di una retribuzione), oppure vendendo il software open-source come un servizio (SaaS), oppure offrendo il software con due licenze (se il programma open-source viene usato in un progetto proprietario si usa una licenza commerciale in modo che gli sviluppatori siano retribuiti, ma se viene usato in un altro progetto open-source, viene offerto con una normale licenza open-source).
*** Difficoltà di uso:
- Spesso il software libero è meno "user-friendly" rispetto al software commerciale per Windows/OS X, può non avere intefacce grafiche, o può richiedere che l'utilizzatore abbia una minima dimestichezza con GNU/Linux o la riga di comando.
- In ogni caso, anche il software proprietario è comunque complesso e non immediatamente intuitivo da un punto di vista tecnico, ed in ogni caso, è sempre possibile sviluppare interfacce grafiche per programmi a linea di comando.


** Vantaggi del software libero
*** Decentralizzazione del processo di sviluppo:
- Non si annulla, ma si riduce significativamente il c.d. "maintainer hit by a bus problem".
- Nel caso del software proprietario, il suo sviluppo dipende esclusivamente da una sola persona o compagnia, e se venissero a mancare per qualsiasi motivo, il software smetterebbe di essere sviluppato.
- Il software open source è sviluppato da un grande numero di persone, e chiunque può continuare lo sviluppo se qualcosa succede allo sviluppatore principale.
*** Conservazione del codice:
- Il fatto che il codice è liberamente condivisibile significa anche che tutti possono facilmente acquisirne una copia.
- Pertanto, è sempre possibile avere accesso ad una specifica versione del software, a fini di riproducibilità.
*** Possibilità di studiare il codice sorgente:
- Non ci si deve fidare di come funziona il software proprietario, e se il suo funzionamento corrisponde a quanto promesso dagli sviluppatori, ma si può ispezionare il codice sorgente, e compilarlo di persona.
- Se il codice sorgente di un progetto open-source viene compromesso, si può notare subito, perché in linea teorica chiunque può controllare quali modifiche sono state aggiunte.
*** Possibilità di studiare i test del codice sorgente:
- La metodologia di sviluppo "Test-Driven Development" richiede che gli sviluppatori scrivano test per verificare che il software corrisponda alle specifiche tecniche richieste, e che versioni successive non siano soggette a bug già risolti in precedenza (c.d. "regressioni").
- Questa metodologia può essere usata anche nel software proprietario, ma nel caso del software open-source, c'è maggiore trasparenza: tutti possono verificare di persona quali test sono stati eseguiti, se i test sono stati superati, e suggerire altri test.
*** Network effect:
- Dato che può essere usato senza limitazioni, e tutti possono contribuire al suo sviluppo, il software viene diffuso e migliorato rapidamente.
- Per "tutti" si intende che in linea teorica, chiunque abbia le capacità tecniche può contribuire al progetto.
- Spetta agli sviluppatori del progetto controllare che le modifiche proposte siano in buona fede, non siano dannose, siano state testate, siano coerenti con lo scopo del progetto, etc.
- Se esistono disaccordi su come continuare lo sviluppo del software, la natura delle licenze open-source permette di fare un "fork", per cui la parte che è in disaccordo può continuare in autonomia, e i due progetti possono continuare a condividere codice fra di loro.
- Maggiore stabilità:
- Il software viene eseguito da un grande numero di persone, su un grande numero di piattaforme, il che permette di trovare e risolvere errori di programmazione (che potrebbero riguardare solo una piattaforma particolare) più velocemente.
*** Il codice è documentazione:
- Specie nel caso in cui il software open-source re-implementa delle funzionalità che sono presenti solo nel software proprietario mediante tecniche di reverse-engineering, il software open-source diventa di fatto anche quasi una "specifica tecnica" che documenta pubblicamente il funzionamento del software proprietario, in mancanza di una documentazione tecnica ufficiale rilasciata dallo sviluppatore.
- Ad es., NTFS-3G per il formato NTFS, Volatility per il formato del file di ibernazione della RAM di Windows, Wine per l'esecuzione di programmi Windows su Linux, etc.)
*** Convenienza per i progetti proprietari:
- Anche i progetti proprietari possono beneficiare dal diventare (parzialmente) open-source.
- Spesso il software proprietario viene modificato dai suoi utilizzatori per aggiungere nuove funzionalità, o per correggere bug.  Apportare questi miglioramenti sarebbe molto più semplice se il software fosse open-source.
- È possibile rendere open-source anche solo parte del progetto, e lasciare la parte del progetto in cui risiede il vantaggio competitivo del progetto closed-source.
- Ad es., vari programmi offrono una "community edition" gratuita, ed una "enterprise edition" a pagamento; Google Chrome è proprietario, ma Google offre anche Chromium: sono essenzialmente lo stesso browser, con l'unica differenza che Chromium non è integrato con i servizi proprietari di Google.
* GNU/Linux
- Il software è l'ultimo anello nella catena di un computer, ed è preceduto dal sistema operativo e dall'hardware.  La catena è affidabile solo quanto il suo anello più debole.
- È possibile eseguire un programma open-source anche su un sistema operativo proprietario come Windows, ma ci si deve fidare di una "scatola nera", di cui non si conosce l'esatto funzionamento.
- GNU/Linux è un intero sistema operativo open-source, il che permette di portare tutti i vantaggi del software open-source su due anelli della catena.
** Introduzione a GNU/Linux
- Linux: Unix, Minix, Linux.
- GNU: rapporto con Unix, con Linux.
** Gestione dei pacchetti
- A differenza di Windows, non esiste una versione "standard" di GNU/Linux, ma per la natura del software open-source, esistono numerose distribuzioni.
- Gli sviluppatori upstream (a monte) distribuiscono il codice sorgente, indicando di quali librerie il loro programma ha bisogno per funzionare (c.d. dependencies).
- Chi gestisce le distribuzioni GNU/Linux downstream (a monte) riceve il codice sorgente, e lo adatta alle peculiarità della propria distribuzione, e produce un "pacchetto" che contiene le istruzioni per installare il software.
- Successivamente, il software viene installato dagli utenti finali con il gestore di pacchetti della propria distribuzione.
- Modelli di distribuzione:
- Fixed-point: l'intero sistema viene aggiornato semi-periodicamente, il software è stabile ma obsoleto.
- Rolling: ogni componente del sistema viene aggiornato appena è disponibile una nuova versione, il software è sempre aggiornato, ma potrebbe essere instabile.
- Functional:
  - Il sistema viene aggiornato appena è disponibile una nuova versione, ma le versioni precedenti rimangono comunque disponibili, e si può tornare ad utilizzarle in qualsiasi momento.
  - Questo permette di avere un sistema pienamente riproducibile.
- Pacchetti binari, pacchetti sorgente:
- Le distribuzioni normalmente offrono pacchetti già compilati (binari), così che possano essere utilizzati subito.  Questo implica doversi fidare degli sviluppatori upstream.
- Volendo (alcune distribuzioni lo fanno di default) è possibile scaricare un pacchetto sorgente, in modo da ispezionare i suoi contenuti (in particolare, le modifiche che sono state apportate per adeguare il software alla distribuzione) prima di compilarlo ed utilizzarlo.
* Information security (sicurezza informatica)
- Obiettivi: garantire l'integrità (evitare modifiche indesiderate) e confidenzialità (evitare accessi indesiderati) delle informazioni.
- Collegamenti legali: regolamenti sulla privacy, data breach, leggi che regolano la crittografia, leggi che autorizzano o richiedono l'uso di misure di sicurezza informatiche (firme digitali).
- Collegamenti alla DF: la DF interviene dopo che le misure di sicurezza sono state violate per capire cosa sia successo, e quali dati sono stati compromessi, le tecniche di sicurezza dei dati ostacolano l'analisi forense (ad es., crittografia dell'intero disco, captatori informatici che usano vulnerabilità dei dispositivi, etc...)
** Crittografia
- La crittografia di sua natura deve essere "open-source", in modo che sia gli algoritmi, sia il codice sorgente che li implementa, sia soggetto a peer-review.
- Qualsiasi sistema crittografico che non sia pubblicamente discusso è intrisecamente inaffidabile, ed anche i sistemi pubblicamente disponibili devono essere considerati insicuri fino a prova contraria.
- La crittografia viene largamente usata per proteggere le informazioni (sia in transito, sia salvate su disco), e per dimostare la propria identità (le firme digitali richieste dalla PA, utilizzate dagli sviluppatori nelle reproducibile builds).
- Gli algoritmi crittografici sono importanti anche per l'hash dei dati per la digital forensics.
- Regolamentazione della crittografia per limitarne l'efficacia da parte dei governi, così da non limitare le operazioni di surveillance.
** Penetration testing
- L'open-source aiuta a prevenire la "security through obscurity", dove un sistema è considerato sicuro solo perché i meccanismi del suo funzionamento non sono noti al pubblico.
- L'hacking etico ed autorizzato, dette anche operazioni di "red team" (contrapposto al "blue team", che prepara il sistema da difendere) serve a provare la sicurezza dei sistemi informatici.
- Si usano le stesse tecniche che sarebbero usate da un cybercriminale, in modo da prevenire eventuali attacchi.
- Esistono distribuzioni GNU/Linux dedicate all'ethical hacking, come Kali Linux ed altre.
- Le caratteristiche del software open-source sono utili per gli strumenti dedicati a valutare la sicurezza di un sistema informatico.
- L'effetto rete e la concentrazione di conoscenza permette di costruire più rapidamente delle sequenze di test che verificano se un sistema è vulnerabile ad un certo tipo di attacchi informatici.
- Anche se il software di cui si deve provare la sicurezza rimane proprietario, è importante che il software che esegue quelle sequenze di test sia open-source, in modo da permettere una sorta di "peer-review" del loro contenuto, il loro continuo aggiornamento mano a mano che vengono scoperte nuove vulnerabilità.
- Il costo nullo e la facilità di distribuzione rendono questi strumenti disponibili a chiunque abbia il tempo e le conoscenze tecniche per impararli ad utilizzare, e più persone "bene intenzionate" hanno la capacità di verificare se un sistema sia sicuro o meno, e più è probabile che eventuali vulnerabilità nel sistema siano risolte prima che vengano abusate da criminali.
- Esempi di progetti open-source per la sicurezza come Metasploit, American Fuzzy Lop, etc.

** Analisi del malware con Ghidra

* Digital forensics (informatica forense)
** Obiettivi
- Garantire la conservazione della prova digitale dal momento dell'acquisizione in poi.
- Interpretare i dati, e riscostruire le dinamiche che hanno portato a quell'assetto
- In particolare, capire se i dati sono stati manipolati prima o dopo l'acquisizione, e se accidentalmente o di proposito.
** Collegamenti legali
- Codice penale: regola i reati contro sistemi informatici, ma l'informatica forense può essere utilizzata per raccogliere informazioni da sistemi informatici anche dopo il compimento di reati tradizionali.
- Codice di procedura penale: detta i principi generali su come trattare le prove informatiche.
- Standard tecnici: formalizzano le procedure necessarie per garantire la corretta acquisizione e conservazione della prova digitale.
- Giurisprudenza sulla prova scientifica: come la prova scientifica in generale, e la digital evidence in particolare, devono essere valutate dal giudice, commenti sulle sentenze che trattano di aspetti tecnici della DF.
** Differenze con la sicurezza informatica
- La sicurezza informatica ha natura preventiva, serve ad evitare che i sistemi siano colpiti da attacchi, e non si interessa in maniera particolare di "come" funziona il software, ma solo se il software sia sicuro o meno.
- L'informatica forense interviene durante o dopo un attacco informatico, e serve a raccogliere elementi utili per capire come l'attacco ha avuto inizio, quali dati sono stati sottratti o distrutti, e altri elementi utili per le indagini penali.
- Dato che l'informatica forense deve essere in grado di rilevare le tracce dell'evento, e ricostruire la dinamica dei fatti, per questa disciplina è necessario sapere "come" il software funzioni, quali informazioni produca, ecc.
- Inoltre, mentre la cybersecurity è esclusivamente legata alla protezione di un sistema informatico come oggetto di attacchi, le tecniche di informatica forense possono essere utilizzate anche per reati non informatici.
** Vantaggi del software open-source
- Pieno rispetto del diritto di difesa e del principio del contraddittorio:
  - Se vengono usati strumenti open-source, l'imputato può difendersi meglio, perché può conoscere come funziona il programma.
- Piena riproducibilità dei risultati:
  - Dato che il software open source è liberamente ridistribuibile, è possibile depositare una copia degli strumenti che sono stati utilizzati, o anche dell'intero sistema operativo che è stato utilizzato per svolgere l'analisi, compresi i risultati stessi, senza violare il diritto d'autore.
  - In ogni caso, è sempre possibile ricompilare la esatta versione del programma che era stata utilizzata al momento dell'analisi.
- Costi minori e maggiore efficienza:
  - Non si devono pagare licenze per software proprietario, ed il sistema operativo può essere ottimato per le operazioni di digital forensics.
  - Inoltre, per i programmi che usano la linea di comando, si possono usare i c.d. shell script per automatizzare le operazioni ripetitive
- Maggiore affidabilità:
  - "Open-source" non significa che chiunque può contribuire al progetto, o che gli sviluppatori non siano professionisti o non abbiano conoscenze tecniche.
  - È stato dimostrato che il software open-source tende ad avere meno bug, proprio perché ci sono meno barriere al suo utilizzo e sviluppo.
  - Inoltre, gli sviluppatori non hanno nessun incentivo commerciale a nascondere i difetti del loro programma.
- Maggiore privacy e sicurezza:
  - È ben noto che Windows raccoglie e invia grandi quantità di dati alla Microsoft, ed è probabile che anche il software proprietario includa questo tipo di misure.
  - Viceversa, GNU/Linux ed i programmi open-source non hanno nessun incentivo commerciale a sottrarre dati dagli utenti.
** Acquisizione di dischi
- Collegamenti legali: sequestro di file, quanti dati acquisire (in teoria il minimo indispensabile, ma è necessario acquisire l'intero disco per poter compiere un'analisi completa), conservazione sicura dei dati dopo la loro acquisizione.
- Il kernel Linux può essere compilato in modo che tutti i dispositivi siano montati in sola lettura.
- GNU dd è maggiormente affidabile rispetto al suo equivalente UNIX.
** Acquisizione di dati da fonti che non siano un disco
- Collegamenti legali: acquisizione di file da servizi senza bisogno di rogatoria internazionale.
- Nei casi in cui non sia possibile acquisire un disco con la copia forense, è necessario copiare i singoli file, cercando di preservare quanti più metadati possibile, e disturbando gli altri dati il meno possibile.
- Ad es., acquisizioni di dati da smartphone, da servizi di backup personale come Dropbox o Google Drive, da servizi di data storage come Amazon Web Services, da servizi proprietari come Google Takeout.
** Acquisizione di dati dalla RAM e file di ibernazione
- Collegamenti legali: inaffidabilità intrinseca di questi dati, utilizzabili al più come elemento indiziario.
- Difficoltà tecniche: acquisire la RAM mentre il sistema è acceso va a modificarla, si deve acquisire anche la memoria virtuale salvata su disco/file di swap per avere un'acquisizione completa,  i formati sono proprietari e non documentati, le tecniche di analisi non sono particolarmente raffinate.
** Analisi di un disco
- Collegamenti legali: applicazione delle categorie tradizionali ai dati digitali.
- Autopsy: operazioni che è possibile compiere, confronti con software proprietario.
- Programmi per il data carving, la creazione di timeline.
** Acquisizione di siti internet
- Collegamenti legali: differenza con l'intercettazione come disciplinata dal c.p.p.
- Uso di Wireshark per l'acquisizione forense di siti web.
** Sequestro di Bitcoin
- Collegamenti legali: definizione legale di Bitcoin e criptovalute.
- Le applicazioni per la gestione dei Bitcoin sono generalmente open-source, quindi è più facile sapere dove il wallet viene salvato, in quale formato, e quali altre informazioni utili per le indagini sono generate dal software (ad es., la lista delle transazioni, etc.)
