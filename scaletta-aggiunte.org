* Packages

Control what software is allowed (DFSG), harmonize software with system (init scripts, create users, etc., risk of breaking things with a manual install), signatures in packages (chain of trust?)

* TUI

Unix (text streams are the universal interface), GUI (usability guidelines for mouse, minimum size for items formula, keyboard navigation and autocompletion, historical TTYs and video of one printing on paper)

* Cathedral/bazaar

Methods in FOSS communities, issues with each (examples of projects)

* Documentazione

- Importanza della documentazione in generale:
  - Software proprietario: la documentazione è l'unica /source of truth/ su come funziona e come usare il programma
  - FOSS: la documentazione serve anche a giustificare le scelte che sono state fatte, a livello di architettura del software (come è strutturato), e per documentare eventuali /workaround/, bugfix, etc.
  - Accenno a https://diataxis.fr, distinzione fra i vari tipi di documentazione (tutorial, manuali, /reference guides/)
  - FOSS tradizionalmente includeva solo le /reference guides/, che sono utili solo se si sa già cosa si sta cercando, attualmente la comunità si è ampliata ed esistono molti più tutorial
  - Ad es., per quanto riguarda gli editor di testo:
    - Vim include vimtutor, un /user manual/ ed un /reference manual/, ed anche aiuto su come usare i manuali stessi
    - Emacs è detto /self-documenting/, permette di ispezionare il codice sorgente e modificarlo durante l'esecuzione del programma stesso, le funzioni e variabili sono documentate, il sistema di aiuto spiega come usarlo, e include i manuali anche per gli altri componenti del sistema
- Importanza di mantenere codice e documentazione sincronizzati
  - "Bug" della documentazione: se la documentazione è poco chiara, o se il codice non si comporta come previsto dalla documentazione
- Licenze per la documentazione:
  - Diverse dalle licenze per il codice
  - Si deve scegliere una licenza, altrimenti la documentazione è proprietaria (per la convenzione di Berna)
  - Creative commons (copyleft se si usa la clausola SA), GFDL (problemi con Debian, la considera non-free)
- Modalità di documentazione:
  - Commenti
  - Documentazione funzioni e strutture di dati, /literate programming/ di Knuth
  - Documentazione separata (tutorial, guide alla struttura del programma, linee-guida per contribuire)
- Lettura della documentazione:
  - Manpages, relativi software
  - Texinfo, relativi software
  - Generazione documentazione in file HTML (Sphinx, Doxygen, etc.)

* Curiosità

Open source vs proprietary in LLMs: https://youtube.com/watch?v=9JEMNy4sgkY

Printable compiled code: https://youtube.com/watch?v=LA_DrBwkiJA

CI, Git open-source e self-hosted

GitHub arctic vault

* Nuovo ordine

- Definizione oggetto informatica forense e sicurezza informatica (requisiti, limiti discipline, interazioni)
- Discussione FOSS disponibile per le discipline (questioni giuridiche, tecniche)
- Definizione FOSS, discussione vantaggi (difficile distinguere le due)
- Sistemi a supporto del software FOSS (documentazione tecnica libera - tensione legale con segreti industriali, dati necessari per l'uso del software liberi - ad es., driver, etc., VCS, CI, compilatori FOSS e confronto con proprietari, etc...) - analogie con il diritto amministrativo (pubblicità dei dati, procedimento che serve a garantire un livello di qualità e figure responsabili per il raggiungimento degli obiettivi più critici)
- Sistemi operativi FOSS (GNU/Linux, vantaggi)
- Hardware FOSS (RISC, smartphone libre, Pinebook...)

* Da ricercare

Cercare fondazioni/advocacy per il FOSS, attività di promozione e lobbying anche legale, adozione da parte dei governi

Giurisprudenza amministrativa sugli algoritmi

Responsabilità per il software

* Sicurezza informatica

- SSH: amministrare un server remoto
- Pacchetti: aggiornamenti per la sicurezza
- fail2ban, UFW: firewall, blocco IP con cattiva reputazione
- Security audit di software (ad es., gocryptfs, restic), definizione del /threat model/
- Limiti dell'open source: 0day/vulnerabilità e /responsible disclosure/ (rischio che siano sfruttate, vanno comunicate in privato, /bug bounties/ per incentivare la loro comunicazione agli sviluppatori), malware open-source (RE è utile, ma fornire il sorgente può semplificare il lavoro dei malware developer, cf. virus Mirai)
- Crittografia: branca della sicurezza informatica che i governi regolano espressamente, perché ostacola le indagini (uso di comunicazioni private da parte di cyber-criminali e terroristi, ma errore umano, Silk Road, metadati su Twitter)
- Fuzzing: /untrusted, unsanitized input/, si applica anche alla digital forensics (ma più per garantire che il programma sia robusto anche in presenza di dati inaspettati o corrotti, /anti-forensics/, più che per evitare danni da exploit, anche se in teoria è possibile, come /stagefright/, etc.)

* "Formalizzazione" e procedimentalizzazione delle buone pratiche di sviluppo del software

- Ossia, documentazione, test e CI, static analysis, fuzzying, etc.
- Cercare richiami in regolamenti governativi, ordinanze, raccomandazioni, etc.
- Se non ci sono richiami, evidenziare la necessità e opportunità che lo sviluppo del software sia regolato da un "procedimento" che serve a garantire e legittimare la sua affidabilità, come l'attività amministrativa
- Creazione di figure specifiche, responsabili per le materie più delicate (ad es., il team per la sicurezza di Debian)

* Evoluzione del software proprietario

Perché i programmi erano open-source:

- Le macchine erano programmate manualmente (come un abaco)
- Le macchine servivano ad uno scopo specifico, o avevano una ROM limitata, non c'è grande margine di espressione creativa
- I protrammatori scrivevsni direttamente in codice macchina (ad es NASA), non esistevano compilatori
- I computer erano usati per progetti di ricerca, prima che per scopi commerciali (cf. il personal computer negli uffici di imprese, vs. ricercatori)
